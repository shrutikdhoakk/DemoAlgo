# Zerodha Execution & Risk Orchestration Engine

This repository contains a minimal implementation of the execution and risk
orchestration engine described in the *Execution & Risk Orchestration Runbook â€“
India Broker API*.  It is designed as a starting point for running a
semiâ€‘automated trading system with Zerodhaâ€™s Kite API while enforcing
regulatoryâ€‘compliant preâ€‘trade gates, order slicing, stop management and realâ€‘time
supervision.

> **Important:** This code is provided for educational purposes.  It is not
> financial advice.  Use at your own risk and ensure that you understand
> all regulatory requirements before trading live capital.

## Features

- **Configuration via YAML** â€“ all risk limits, broker credentials and
  instrument settings live in `config.yaml`.
- **OAuth login flow** â€“ `app.py` hosts a tiny Flask application that
  completes the Kite login flow and persists the daily access token in
  `.env`.
- **WebSocket ticker** â€“ `ws_client.py` subscribes to realâ€‘time ticks for
  configured symbols and broadcasts them to the engine.
- **Risk engine & order manager** â€“ `engine.py` ingests signals, runs
  preâ€‘trade checks (connectivity, margin, symbol whitelist, ADV sizing,
  priceâ€‘band validation, news sentiment placeholder, etc.), slices orders
  and submits them to Zerodha.  It also handles stop and trailing logic
  serverâ€‘side if the broker lacks native functionality.
- **Logging & audit** â€“ All signals, orders, responses and risk decisions
  are logged to the `logs/` folder for compliance.

## Prerequisites

1. **PythonÂ 3.10+** â€“ install the required packages:

   ```bash
   pip install -r requirements.txt
   ```

2. **Zerodha developer account** â€“ create an app on
   [developers.kite.trade](https://developers.kite.trade/) with type
   **Connect**.  Set the redirect URL to `http://127.0.0.1:5000/kite/callback` for
   local development.  After creation, copy the API key and secret into
   `config.yaml`.

3. **Instruments CSV** â€“ download the full instruments file from the Kite
   developer portal (it contains columns `instrument_token`, `tradingsymbol`
   and `exchange`).  Save it as `instruments.csv` in this repository.  The
   engine uses it to map humanâ€readable symbols to instrument tokens for
   WebSocket subscriptions.

4. **Setup `.env`** â€“ copy `.env.example` to `.env` and fill in any
   secrets.  The access token will be written here by `app.py` after
   successful login each day.  **Do not commit your `.env` file to
   version control.**

## How to run

1. **Configure your parameters** â€“ edit `config.yaml` to set your
   environment (`SIM` or `LIVE`), broker details, risk limits, stop
   parameters and monitoring email address.  Example values are provided.

2. **Login to Kite** â€“ run the Flask app once per day to obtain a fresh
   `access_token` and write it into `.env`:

   ```bash
   python app.py
   ```

   Then open `http://127.0.0.1:5000/kite/login` in your browser and log in
   with your Zerodha credentials.  After authentication, you should see
   â€œLogin OK. Access token saved.â€  The `.env` file will now contain
   `KITE_ACCESS_TOKEN=` which is valid for the current trading day.

3. **Start the ticker** â€“ in a separate terminal, run:

   ```bash
   python ws_client.py
   ```

   This subscribes to the symbols specified in `config.yaml` and writes
   tick messages into an inâ€‘memory queue consumed by the engine.

4. **Launch the engine** â€“ finally, in another terminal, start the
   execution engine:

   ```bash
   python engine.py
   ```

   The engine listens for dummy signals generated by the sample `signals.py`
   (or replace it with your real strategy).  For each signal it runs the
   preâ€‘trade gates, slices the order, submits to Zerodha and manages
   serverâ€‘side stops.  All decisions are logged.

## Developing your own signals

The file `signals.py` contains a simple example that emits a buy or sell
signal every few seconds.  Replace this logic with your own strategy or
connect it to your quantitative signal stream.  Make sure that each
signal dictionary contains:

- `symbol` â€“ e.g. `RELIANCE`
- `side` â€“ `BUY` or `SELL`
- `quantity` â€“ intended number of shares
- `time_in_force` â€“ `DAY`, `IOC`, etc.
- `limit_price` (optional) â€“ if omitted, the engine will compute a
  conservative limit around the LTP/nbbo.

All signals pass through the preâ€‘trade gate before being executed.

## Disclaimer

Trading involves risk of substantial loss.  This project does not take
responsibility for financial outcomes.  Always backâ€‘test and paperâ€‘trade
before going live and ensure compliance with SEBI regulations.

Git Hub code to use to work

cd C:\Users\shrut\DemoAlgo
code .

Git Hub code to Save the work

git add .
git commit -m "Describe your change"
git push origin main

Backtest strategy (ðŸ”¹ Strategy Used: Breakout + Momentum Swing Trading

The backtest is not a generic SMA/EMA crossover â€” itâ€™s a high-probability breakout strategy with multiple technical filters.

1. Entry Logic (when to BUY)

For each stock:

Breakout filter

Price > 20-day high (HH20) or > 50-day high (HH50).

Momentum filter

ADX > ADX_MIN (default 20) â†’ ensures a trending market.

RSI filter

RSI(7), RSI(14), RSI(21) all > RSI_MIN_ALL (default 40) â†’ avoids weak momentum.

Volume filter

Todayâ€™s Volume > VOL_MULT Ã— avg20 (default 1.5Ã— average volume).

Scoring system

Ranks candidates by a weighted score of breakout strength, ADX, and RSI.

Only top candidates are selected (max MAX_POSITIONS, default 5).

Risk sizing

Position size = min(cash budget, ATR-based risk cap).

Risk per trade limited by PER_TRADE_RISK (default â‚¹1000).

2. Exit Logic (when to SELL)

Each position is monitored daily:

Stop-loss:

ATR-based stop (price â€“ ATR_STOP_MULT Ã— ATR).

Target:

ATR-based target (price + ATR_TGT_MULT Ã— ATR).

Trailing:

Both stop and target trail with price as ATR changes.

Other exit conditions:

Price falls below 20-day SMA.

RSI(14) < RSI_EXIT_BELOW (default 30).

Forced exit:

All positions closed on last day of backtest.

3. Risk & Portfolio Controls

Max capital deployed: MAX_INVESTED (default â‚¹5000 of â‚¹10000).

Max positions: MAX_POSITIONS (default 5).

Slippage + fees:

0.10% slippage + 0.03% fees per side.

4. Indicators Used

ATR (Average True Range) â†’ for position sizing + stop/target.

ADX â†’ ensures trend strength.

RSI(7,14,21) â†’ momentum confirmation.

HH20 & HH50 â†’ breakout levels.

SMA20 â†’ exit condition.

Volume filter â†’ avoid false breakouts.)

ðŸ”¹ Strategy Used: Breakout + Momentum Swing Trading

The backtest is not a generic SMA/EMA crossover â€” itâ€™s a high-probability breakout strategy with multiple technical filters.

1. Entry Logic (when to BUY)

For each stock:

Breakout filter

Price > 20-day high (HH20) or > 50-day high (HH50).

Momentum filter

ADX > ADX_MIN (default 20) â†’ ensures a trending market.

RSI filter

RSI(7), RSI(14), RSI(21) all > RSI_MIN_ALL (default 40) â†’ avoids weak momentum.

Volume filter

Todayâ€™s Volume > VOL_MULT Ã— avg20 (default 1.5Ã— average volume).

Scoring system

Ranks candidates by a weighted score of breakout strength, ADX, and RSI.

Only top candidates are selected (max MAX_POSITIONS, default 5).

Risk sizing

Position size = min(cash budget, ATR-based risk cap).

Risk per trade limited by PER_TRADE_RISK (default â‚¹1000).

2. Exit Logic (when to SELL)

Each position is monitored daily:

Stop-loss:

ATR-based stop (price â€“ ATR_STOP_MULT Ã— ATR).

Target:

ATR-based target (price + ATR_TGT_MULT Ã— ATR).

Trailing:

Both stop and target trail with price as ATR changes.

Other exit conditions:

Price falls below 20-day SMA.

RSI(14) < RSI_EXIT_BELOW (default 30).

Forced exit:

All positions closed on last day of backtest.

3. Risk & Portfolio Controls

Max capital deployed: MAX_INVESTED (default â‚¹5000 of â‚¹10000).

Max positions: MAX_POSITIONS (default 5).

Slippage + fees:

0.10% slippage + 0.03% fees per side.

4. Indicators Used

ATR (Average True Range) â†’ for position sizing + stop/target.

ADX â†’ ensures trend strength.

RSI(7,14,21) â†’ momentum confirmation.

HH20 & HH50 â†’ breakout levels.

SMA20 â†’ exit condition.

Volume filter â†’ avoid false breakouts.