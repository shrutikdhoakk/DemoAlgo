# Zerodha Execution & Risk Orchestration Engine

This repository contains a minimal implementation of the execution and risk
orchestration engine described in the *Execution & Risk Orchestration Runbook –
India Broker API*.  It is designed as a starting point for running a
semi‑automated trading system with Zerodha’s Kite API while enforcing
regulatory‑compliant pre‑trade gates, order slicing, stop management and real‑time
supervision.

> **Important:** This code is provided for educational purposes.  It is not
> financial advice.  Use at your own risk and ensure that you understand
> all regulatory requirements before trading live capital.

## Features

- **Configuration via YAML** – all risk limits, broker credentials and
  instrument settings live in `config.yaml`.
- **OAuth login flow** – `app.py` hosts a tiny Flask application that
  completes the Kite login flow and persists the daily access token in
  `.env`.
- **WebSocket ticker** – `ws_client.py` subscribes to real‑time ticks for
  configured symbols and broadcasts them to the engine.
- **Risk engine & order manager** – `engine.py` ingests signals, runs
  pre‑trade checks (connectivity, margin, symbol whitelist, ADV sizing,
  price‑band validation, news sentiment placeholder, etc.), slices orders
  and submits them to Zerodha.  It also handles stop and trailing logic
  server‑side if the broker lacks native functionality.
- **Logging & audit** – All signals, orders, responses and risk decisions
  are logged to the `logs/` folder for compliance.

## Prerequisites

1. **Python 3.10+** – install the required packages:

   ```bash
   pip install -r requirements.txt
   ```

2. **Zerodha developer account** – create an app on
   [developers.kite.trade](https://developers.kite.trade/) with type
   **Connect**.  Set the redirect URL to `http://127.0.0.1:5000/kite/callback` for
   local development.  After creation, copy the API key and secret into
   `config.yaml`.

3. **Instruments CSV** – download the full instruments file from the Kite
   developer portal (it contains columns `instrument_token`, `tradingsymbol`
   and `exchange`).  Save it as `instruments.csv` in this repository.  The
   engine uses it to map human‐readable symbols to instrument tokens for
   WebSocket subscriptions.

4. **Setup `.env`** – copy `.env.example` to `.env` and fill in any
   secrets.  The access token will be written here by `app.py` after
   successful login each day.  **Do not commit your `.env` file to
   version control.**

## How to run

1. **Configure your parameters** – edit `config.yaml` to set your
   environment (`SIM` or `LIVE`), broker details, risk limits, stop
   parameters and monitoring email address.  Example values are provided.

2. **Login to Kite** – run the Flask app once per day to obtain a fresh
   `access_token` and write it into `.env`:

   ```bash
   python app.py
   ```

   Then open `http://127.0.0.1:5000/kite/login` in your browser and log in
   with your Zerodha credentials.  After authentication, you should see
   “Login OK. Access token saved.”  The `.env` file will now contain
   `KITE_ACCESS_TOKEN=` which is valid for the current trading day.

3. **Start the ticker** – in a separate terminal, run:

   ```bash
   python ws_client.py
   ```

   This subscribes to the symbols specified in `config.yaml` and writes
   tick messages into an in‑memory queue consumed by the engine.

4. **Launch the engine** – finally, in another terminal, start the
   execution engine:

   ```bash
   python engine.py
   ```

   The engine listens for dummy signals generated by the sample `signals.py`
   (or replace it with your real strategy).  For each signal it runs the
   pre‑trade gates, slices the order, submits to Zerodha and manages
   server‑side stops.  All decisions are logged.

## Developing your own signals

The file `signals.py` contains a simple example that emits a buy or sell
signal every few seconds.  Replace this logic with your own strategy or
connect it to your quantitative signal stream.  Make sure that each
signal dictionary contains:

- `symbol` – e.g. `RELIANCE`
- `side` – `BUY` or `SELL`
- `quantity` – intended number of shares
- `time_in_force` – `DAY`, `IOC`, etc.
- `limit_price` (optional) – if omitted, the engine will compute a
  conservative limit around the LTP/nbbo.

All signals pass through the pre‑trade gate before being executed.

## Disclaimer

Trading involves risk of substantial loss.  This project does not take
responsibility for financial outcomes.  Always back‑test and paper‑trade
before going live and ensure compliance with SEBI regulations.

Git Hub code to use to work

cd C:\Users\shrut\DemoAlgo
code .

Git Hub code to Save the work

git add .
git commit -m "Describe your change"
git push origin main

Backtest strategy (🔹 Strategy Used: Breakout + Momentum Swing Trading

The backtest is not a generic SMA/EMA crossover — it’s a high-probability breakout strategy with multiple technical filters.

1. Entry Logic (when to BUY)

For each stock:

Breakout filter

Price > 20-day high (HH20) or > 50-day high (HH50).

Momentum filter

ADX > ADX_MIN (default 20) → ensures a trending market.

RSI filter

RSI(7), RSI(14), RSI(21) all > RSI_MIN_ALL (default 40) → avoids weak momentum.

Volume filter

Today’s Volume > VOL_MULT × avg20 (default 1.5× average volume).

Scoring system

Ranks candidates by a weighted score of breakout strength, ADX, and RSI.

Only top candidates are selected (max MAX_POSITIONS, default 5).

Risk sizing

Position size = min(cash budget, ATR-based risk cap).

Risk per trade limited by PER_TRADE_RISK (default ₹1000).

2. Exit Logic (when to SELL)

Each position is monitored daily:

Stop-loss:

ATR-based stop (price – ATR_STOP_MULT × ATR).

Target:

ATR-based target (price + ATR_TGT_MULT × ATR).

Trailing:

Both stop and target trail with price as ATR changes.

Other exit conditions:

Price falls below 20-day SMA.

RSI(14) < RSI_EXIT_BELOW (default 30).

Forced exit:

All positions closed on last day of backtest.

3. Risk & Portfolio Controls

Max capital deployed: MAX_INVESTED (default ₹5000 of ₹10000).

Max positions: MAX_POSITIONS (default 5).

Slippage + fees:

0.10% slippage + 0.03% fees per side.

4. Indicators Used

ATR (Average True Range) → for position sizing + stop/target.

ADX → ensures trend strength.

RSI(7,14,21) → momentum confirmation.

HH20 & HH50 → breakout levels.

SMA20 → exit condition.

Volume filter → avoid false breakouts.)

🔹 Strategy Used: Breakout + Momentum Swing Trading

The backtest is not a generic SMA/EMA crossover — it’s a high-probability breakout strategy with multiple technical filters.

1. Entry Logic (when to BUY)

For each stock:

Breakout filter

Price > 20-day high (HH20) or > 50-day high (HH50).

Momentum filter

ADX > ADX_MIN (default 20) → ensures a trending market.

RSI filter

RSI(7), RSI(14), RSI(21) all > RSI_MIN_ALL (default 40) → avoids weak momentum.

Volume filter

Today’s Volume > VOL_MULT × avg20 (default 1.5× average volume).

Scoring system

Ranks candidates by a weighted score of breakout strength, ADX, and RSI.

Only top candidates are selected (max MAX_POSITIONS, default 5).

Risk sizing

Position size = min(cash budget, ATR-based risk cap).

Risk per trade limited by PER_TRADE_RISK (default ₹1000).

2. Exit Logic (when to SELL)

Each position is monitored daily:

Stop-loss:

ATR-based stop (price – ATR_STOP_MULT × ATR).

Target:

ATR-based target (price + ATR_TGT_MULT × ATR).

Trailing:

Both stop and target trail with price as ATR changes.

Other exit conditions:

Price falls below 20-day SMA.

RSI(14) < RSI_EXIT_BELOW (default 30).

Forced exit:

All positions closed on last day of backtest.

3. Risk & Portfolio Controls

Max capital deployed: MAX_INVESTED (default ₹5000 of ₹10000).

Max positions: MAX_POSITIONS (default 5).

Slippage + fees:

0.10% slippage + 0.03% fees per side.

4. Indicators Used

ATR (Average True Range) → for position sizing + stop/target.

ADX → ensures trend strength.

RSI(7,14,21) → momentum confirmation.

HH20 & HH50 → breakout levels.

SMA20 → exit condition.

Volume filter → avoid false breakouts.